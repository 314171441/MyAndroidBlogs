| Markdown版本笔记 | 我的GitHub首页 | 我的博客 | 我的微信 | 我的邮箱 |  
| :------------: | :------------: | :------------: | :------------: | :------------: |  
| [MyAndroidBlogs][Markdown] | [baiqiantao][GitHub] | [baiqiantao][博客] | bqt20094 | baiqiantao@sina.com |  
  
[Markdown]:https://github.com/baiqiantao/MyAndroidBlogs  
[GitHub]:https://github.com/baiqiantao  
[博客]:http://www.cnblogs.com/baiqiantao/  
  
  
***  
目录  
===  

- [MD5 SHA1 示例](#MD5-SHA1-示例)
- [MD5 简介](#MD5-简介)
	- [正确认识 MD5](#正确认识-MD5)
	- [HASH 函数](#HASH-函数)
	- [Hash 相关概念](#Hash-相关概念)
	- [常用 Hash 算法](#常用-Hash-算法)
- [MD5 碰撞](#MD5-碰撞)
	- [个人对密码破解的理解](#个人对密码破解的理解)
	- [MD5碰撞大事件--王小云](#MD5碰撞大事件--王小云)
	- [MD5碰撞测试](#MD5碰撞测试)
	- [推荐一个 MD5 密码碰撞网站](#推荐一个-MD5-密码碰撞网站)
  
# MD5 SHA1 示例  
  
打印日志  
```java  
字符串1的MD5签名为(32)【C4CA4238A0B923820DCC509A6F75849B】  
字符串1的SHA-1签名为(40)【356A192B7913B04C54574D18C28D46E6395428AB】  
  
文件1的MD5签名为(32)【18FCC4334F44FED60718E7DACD82DDDF】  
文件2的MD5签名为(32)【18FCC4334F44FED60718E7DACD82DDDF】  
文件1的SHA1签名为(40)【0033F995A30FD2CCBF60CC1E7D7DB9E649397668】  
文件2的SHA1签名为(40)【30ACE7E13A7F9DC9ABBAA431241309AC6741E735】  
```  
  
两个相同MD5值的文件下载地址：  
[HelloWorld-colliding.exe](http://www.win.tue.nl/hashclash/SoftIntCodeSign/HelloWorld-colliding.exe)  
[GoodbyeWorld-colliding.exe](http://www.win.tue.nl/hashclash/SoftIntCodeSign/GoodbyeWorld-colliding.exe)  
  
示例代码  
```java  
public class MessageDigestUtils {  
    public static void main(String[] args) throws Exception {  
        String md5 = getStrMessageDigest("1", "MD5");// 【C4CA4238A0B923820DCC509A6F75849B】  
        System.out.println("字符串1的MD5签名为(" + md5.length() + ")【" + md5 + "】");  
        String sha1 = getStrMessageDigest("1", "SHA-1");// 【356A192B7913B04C54574D18C28D46E6395428AB】  
        System.out.println("字符串1的SHA-1签名为(" + sha1.length() + ")【" + sha1 + "】\n");  
  
        // 下面是两个不同的文件，但是它们的 MD5 都是一样的，这就是科学家通过碰撞破解签名的案例  
        File file1 = new File("D:/HelloWorld-colliding.exe"), file2 = new File("D:/GoodbyeWorld-colliding.exe");  
        String file1Md5 = getFileMessageDigest(file1, "MD5");// 【18FCC4334F44FED60718E7DACD82DDDF】  
        String file2Md5 = getFileMessageDigest(file2, "MD5");// 【18FCC4334F44FED60718E7DACD82DDDF】  
        String file1Sha1 = getFileMessageDigest(file1, "SHA-1");// 【0033F995A30FD2CCBF60CC1E7D7DB9E649397668】  
        String file2Sha1 = getFileMessageDigest(file2, "SHA-1");// 【30ACE7E13A7F9DC9ABBAA431241309AC6741E735】  
        System.out.println("文件1的MD5签名为(" + file1Md5.length() + ")【" + file1Md5 + "】");  
        System.out.println("文件2的MD5签名为(" + file2Md5.length() + ")【" + file2Md5 + "】");  
        System.out.println("文件1的SHA1签名为(" + file1Sha1.length() + ")【" + file1Sha1 + "】");  
        System.out.println("文件2的SHA1签名为(" + file2Sha1.length() + ")【" + file2Sha1 + "】");  
    }  
  
    // 获取字符串的签名  
    public static String getStrMessageDigest(String input, String algorithm) {  
        try {  
            MessageDigest md = MessageDigest.getInstance(algorithm);  
            md.update(input.getBytes("utf-8"));  
            byte temp[] = md.digest();  
            return encode(temp);  
        } catch (Exception e) {  
            e.printStackTrace();  
            return null;  
        }  
    }  
  
    // 获取文件的签名  
    public static String getFileMessageDigest(File file, String algorithm) {  
        FileInputStream fis = null;  
        try {  
            MessageDigest md = MessageDigest.getInstance(algorithm);  
            fis = new FileInputStream(file);  
            byte[] buffer = new byte[1024];  
            int length;  
            while ((length = fis.read(buffer)) != -1) {  
                md.update(buffer, 0, length);  
            }  
            return encode(md.digest());  
        } catch (Exception e) {  
            return null;  
        } finally {  
            try {  
                if (fis != null)  
                    fis.close();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
  
    // 将二进制转换成16进制  
    public static String encode(byte buf[]) {  
        StringBuffer sb = new StringBuffer();  
        for (int i = 0; i < buf.length; i++) {  
            String hex = Integer.toHexString(buf[i] & 0xFF);  
            hex = (hex.length() == 1) ? ('0' + hex) : hex;  
            sb.append(hex.toUpperCase());  
        }  
        return sb.toString();  
    }  
  
    // 将16进制转换为二进制  
    public static byte[] deocde(String hexStr) {  
        byte[] result = new byte[hexStr.length() / 2];  
        for (int i = 0; i < hexStr.length() / 2; i++) {  
            int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);  
            int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);  
            result[i] = (byte) (high * 16 + low);  
        }  
        return result;  
    }  
}  
```  
  
# MD5 简介  
Message-Digest Algorithm 5（MD5，消息摘要算法第五版）为计算机安全领域广泛使用的一种散列函数，用于确保【信息传输完整一致】，是计算机广泛使用的杂凑算法（又称摘要算法、哈希算法）之一。将数据运算为另一固定长度值，是杂凑算法的基础原理。MD5的前身有MD2、MD3和MD4。  
  
MD5算法具有以下特点：  
- `压缩性`：任意长度的数据，算出的MD5值长度都是固定的。  
- `容易计算`：从原数据计算出MD5值很容易。  
- `抗修改性`：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。  
- `强抗碰撞`：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。  
  
MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等。  
  
## 正确认识 MD5  
- 算法的公开并不意味着不安全，RSA 的算法也是公开的，AES 也是公开的，`现代密码学的安全性从不是靠算法的保密来保证的`。  
- 目前没有软件能有效地破解 MD5，大多数时候只是把常见字符串的 MD5 存了起来为彩虹表，然后直接反查。  
- 再次强调 `MD5 只是哈希，而不是加密`，`MD5 是没有可能解密的`，因为一个 MD5 可能对应无数种可能的明文。  
- MD5 目前来说还是可以用的，尤其是考虑到合适的加盐以后可以解决大多数彩虹表带来的危险。当然现在已经很多人提倡用 SHA 系列的哈希算法取代 MD5。  
  
## HASH 函数  
HASH函数，又称`杂凑函数`，是在信息安全领域有广泛和重要应用的密码算法，它有一种类似于`指纹`的应用。在网络安全协议中，杂凑函数用来处理电子签名，将冗长的签名文件压缩为一段独特的数字信息，像指纹鉴别身份一样保证原来数字签名文件的合法性和安全性。SHA-1和MD5都是目前最常用的杂凑函数。经过这些算法的处理，原始信息即使只更动一个字母，对应的压缩信息也会变为截然不同的“指纹”，这就保证了经过处理信息的唯一性。为电子商务等提供了数字认证的可能性。  
  
安全的杂凑函数在设计时必须满足两个要求：其一是`寻找两个输入得到相同的输出值在计算上是不可行的`（已知输入，【伪造】另一个输入），这就是我们通常所说的`抗碰撞`的；其二是`找一个输入能得到给定的输出在计算上是不可行的`（已知输出，【破解】输入），即不可从结果推导出它的初始状态。现在使用的重要计算机安全协议，如SSL，PGP都用杂凑函数来进行签名，一旦找到两个文件可以产生相同的压缩值，就可以伪造签名，给网络安全领域带来巨大隐患。  
  
Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把【任意长度】的输入(又叫做预映射, pre-image)，通过散列算法，变换成【固定长度】的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，`不同的输入可能会散列成相同的输出`(因为输入是无限的，而输出是有限的)，所以不可能从散列值来唯一的确定输入值(一个输出对应无穷尽个输入)。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。  
  
所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果。但另一方面，散列函数的输入和输出不是一一对应的，如果两个散列值相同，两个输入值很可能是相同的，但并不能绝对肯定二者一定相等。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。  
  
## Hash 相关概念  
  
若结构中存在和关键字K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数(Hash function)，按这个事先建立的表为散列表。  
  
对不同的关键字可能得到同一散列地址，即key1≠key2，而f(key1)=f(key2)，这种现象称碰撞。具有相同函数值的关键字对该散列函数来说称做同义词。  
  
综上所述，根据散列函数H(key)和处理冲突的方法将一组关键字映象到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“象” 作为记录在表中的存储位置，这种表便称为散列表，这一映象过程称为散列造表或散列，所得的存储位置称散列地址。  
  
若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数(Uniform Hash function)，这就是使关键字经过散列函数得到一个"随机的地址"，从而减少冲突。  
  
## 常用 Hash 算法  
  
MD5和SHA-1可以说是目前应用最广泛的Hash算法，而它们都是以MD4为基础设计的。  
- MD4：MD4(RFC 1320)是 MIT 的Ronald L. Rivest在 1990 年设计的，MD 是 Message Digest（消息摘要） 的缩写。它适用在32位字长的处理器上用高速软件实现——它是基于 32位操作数的位操作来实现的。  
- MD5：MD5(RFC 1321)是 Rivest 于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 相同。MD5比MD4来得复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好。  
- SHA-1及其他：SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1 设计时基于和MD4相同原理,并且模仿了该算法。  
  
# MD5 碰撞  
[MD5反向查询网站](http://www.cmd5.com/)  
[文件MD5值查询网站](http://www.atool.org/file_hash.php)  
  
## 个人对密码破解的理解  
  
**使用MD5对密码加密后传输或保存有什么用？**  
一个输入(密码明文)有唯一的一个输出(加密后的密文)，但反过来，一个输出却对应无数个输入，所以，当你拿到一个输出时，不可能确定是哪个输入。也就是说，虽然你获取到了别人的密文，但是输入时要的是明文，你不可能通过密文反推明文，也就保证了安全。  
  
> 简单来说就是，数据库虽然保存了用户的密码，但任何人都不知道用户的原始密码是什么  
  
**那为什么这个网站还能通过密文破解出明文呢？**  
其实道理很简单，虽然一个输出对应无数个输入，但平时`我们接触到的输入`并不是无限的。比如很多网站对密码有一些特殊要求：只能为6-20位的字母、数字等符号的组合。就这么一条平常的限制，就将`无限种可能的输入缩小到有限种可能的输入`了。既然是有限的，那就可以把这些所有可能的输入及其对应的输出全部列出来（散列表），这时，当然就可以通过输出反推输入了。  
且因为输出为32位，输入一般远低于32位(谁的密码那么长呀)，所以极有可能通过输出反推得到的输入是唯一的(但这并不是可以确定的事，完全也有可能一个输出对应多个输入)。  
  
**那MD5岂不是没有卵用了？**  
此言差矣。即使要求密码为8位，同时要求密码只能是字母和数字(共26+26+10=62种字符)，那么通过排列组合出的字典的项数为：`62^8`，这尼玛已经是一个天文数字了，这个号称 [最牛逼的密码破解网站](https://www.cmd5.com) 目前也没收录这么多数据。  
  
> PS：这个网站宣传中说，"任何网站很难收录到8位小写字母，而本站全部收录8位小写字母+数字"，也就是约等于36^8，两者也还相差`(62/36)^`8超过70倍  
  
**我们该怎么防止密码被破解呢？**  
首先根据他们的收录内容可以知道，"1-6位大小写字母+数字+特殊字符"是100%可以破解的，"11位以内的纯数字"是100%可以破解的，"9位以内的小写字母+数字"是很可能会被破解的。  
  
另外，对于md5加密后再加密的情况，根据上面的分析(第2点)，其实和加密一次的效果是完全一样的，很可能也是一一对应的。  
  
不过，对于加密后加盐再加密的情况，在别人不知道salt的情况下，破解难度将大大加强。  
  
结论就是：用户自己设置的密码不能低于8位，不能为纯数字+小写字母，建议包含大写字母，最好包含特殊字符；传输过程一定要加密后再加盐。  
  
**到目前为止，科学家们有没有找出不同的字符串而MD5相同的案例？**  
当然有，但是如果你想为某一个特定的字符串找到与它MD5相同的另一个字符串，这个基本上实现不了的(不知道目前科学界研究的进展如何)。  
  
## MD5碰撞大事件--王小云  
  
MD5就是这样一个在国内外有着广泛的应用的杂凑函数算法，它曾一度被认为是非常安全的。然而，王小云教授发现，可以很快的找到MD5的“碰撞”，就是两个文件可以产生相同的“指纹”。这意味着，当你在网络上使用电子签名签署一份合同后，还可能找到另外一份具有相同签名但内容迥异的合同，这样两份合同的真伪性便无从辨别。王小云教授的研究成果证实了利用MD5算法的碰撞可以严重威胁信息系统安全，这一发现使目前电子签名的法律效力和技术体系受到挑战。因此，业界专家普林斯顿计算机教授Edward Felten等强烈呼吁信息系统的设计者尽快更换签名算法，而且他们强调这是一个需要立即解决的问题。  
  
2004年8月17日的美国加州圣巴巴拉的国际密码学会议（Crypto’2004）上，来自中国山东大学的王小云教授做了破译MD5、HAVAL-128、 MD4和RIPEMD算法的报告，公布了MD系列算法的破解结果。宣告了固若金汤的世界通行密码标准MD5的堡垒轰然倒塌，引发了密码学界的轩然大波。(注意:并非是真正的破解，只是加速了杂凑冲撞）  
  
在2004年8月之前，国际密码学界对王小云这个名字并不熟悉。2004年8月，在美国加州圣芭芭拉召开的国际密码大会上，并没有被安排发言的王小云教授拿着自己的研究成果找到会议主席，没想到慧眼识珠的会议主席破例给了她15分钟时间来介绍自己的成果，而通常发言人只被允许有两三分钟的时间。王小云与助手展示了MD5、SHA-0及其他相关杂凑函数的杂凑冲撞。所谓杂凑冲撞指两个完全不同的讯息经杂凑函数计算得出完全相同的杂凑值。根据鸽巢原理，以有长度限制的杂凑函数计算没有长度限制的讯息是必然会有冲撞情况出现的。可是，一直以来，电脑保安专家都认为要任意制造出冲撞需时太长，在实际情况上不可能发生，而王小云等的发现可能会打破这个必然性。就这样，王小云在国际会议上首次宣布了她及她的研究小组的研究成果——对MD4、MD5、HAVAL-128和RIPEMD等四个著名密码算法的破译结果。  
在公布到第三个成果的时候，会场上已经是掌声四起，报告不得不一度中断。报告结束后，所有与会专家对他们的突出工作报以长时间的掌声，有些学者甚至起立鼓掌以示他们的祝贺和敬佩。由于版本问题，作者在提交会议论文时使用的一组常数和先行标准不同，在发现这一问题之后，王小云教授立即改变了那个常数，在很短的时间内就完成了新的数据分析，这段有惊无险的小插曲更证明了他们论文的信服力，攻击方法的有效性，验证了研究工作的成功。  
  
会议结束时，很多专家围拢到王小云教授身边，既有简短的探讨，又有由衷的祝贺，褒誉之词不绝。包含公钥密码的主要创始人R. L. Rivest和A. Shamir在内的世界顶级的密码学专家也上前表示他们的欣喜和祝贺。  
  
MD5的设计者，同时也是国际著名的公钥加密算法标准RSA的第一设计者R．Rivest在邮件中写道：“这些结果无疑给人非常深刻的印象，她应当得到我最热烈的祝贺，当然，我并不希望看到MD5就这样倒下，但人必须尊崇真理。”  
  
Francois Grieu这样说：“王小云、冯登国、来学嘉和于红波的最新成果表明他们已经成功破译了MD4、MD5、HAVAL-128、RIPEMD-128。并且有望以更低的复杂度完成对SHA-0的攻击。一些初步的问题已经解决。他们赢得了非常热烈的掌声。”  
  
另一位专家Greg Rose如此评价：“我刚刚听了Joux和王小云的报告，王所使用的技术能在任何初始值下用2^40次hash运算找出SHA-0的碰撞。她在报告中对四种HASH函数都给出了碰撞，她赢得了长时间的起立喝彩，（这在我印象中还是第一次）。…… 她是当今密码学界的巾帼英雄。……（王小云教授的工作）技术虽然没有公开，但结果是无庸质疑的，这种技术确实存在。…… 我坐在Ron Rivest前面，我听到他评论道：‘我们不得不做很多的重新思考了。’”  
  
针对王小云教授等破译的以MD5为代表的Hash函数算法的报告，美国国家技术与标准局（NIST）于2004年8月24日发表专门评论，评论的主要内容为：“在最近的国际密码学会议（Crypto 2004）上，研究人员宣布他们发现了破解数种HASH算法的方法，其中包括MD4，MD5，HAVAL-128，RIPEMD还有 SHA-0。分析表明，于1994年替代SHA-0成为联邦信息处理标准的SHA-1的减弱条件的变种算法能够被破解；但完整的SHA-1并没有被破解，也没有找到SHA-1的碰撞。研究结果说明SHA-1的安全性暂时没有问题，但随着技术的发展，技术与标准局计划在2010年之前逐步淘汰SHA-1，换用其他更长更安全的算法（如SHA-224、SHA-256、SHA-384和SHA-512）来替代。”  
  
令世界顶尖密码学家想象不到的是，破解MD5之后，2005年2月，王小云教授又破解了另一国际密码SHA－1。因为SHA－1在美国等国际社会有更加广泛的应用，密码被破的消息一出，在国际社会的反响可谓石破天惊。换句话说，王小云的研究成果表明了从理论上讲电子签名可以伪造，必须及时添加限制条件，或者重新选用更为安全的密码标准，以保证电子商务的安全。  
  
2005年8月，王小云、姚期智，以及姚期智妻子姚储枫（即为Knuth起名高德纳的人）联手于国际密码讨论年会尾声部份提出SHA-1杂凑函数杂凑冲撞演算法的改良版。此改良版使破解SHA-1时间缩短。  
  
2006年6月8日，王小云教授于中国科学院第13次院士大会和中国工程院第8次院士大会上以“国际通用Hash函数的破解”获颁陈嘉庚科学奖信息技术科学奖。  
  
2009年，冯登国、谢涛二人利用差分攻击，将MD5的碰撞算法复杂度从王小云的2^42进一步降低到【2^21】，极端情况下甚至可以降低至2^10。仅仅2^21的复杂度意味着即便是在2008年的计算机上，也只要几秒便可以找到一对碰撞。  
  
## MD5碰撞测试  
  
下面这两个程序会在屏幕上打印出不同的字符  
[GoodbyeWorld-colliding.exe](http://www.win.tue.nl/hashclash/SoftIntCodeSign/GoodbyeWorld-colliding.exe)   
[HelloWorld-colliding.exe](http://www.win.tue.nl/hashclash/SoftIntCodeSign/HelloWorld-colliding.exe)   
但是它们的 MD5 都是一样的，用上面的网站进行计算后，他们的MD5值都为：【18fcc4334f44fed60718e7dacd82dddf】  
  
这是几位密码学家使用“构造前缀碰撞法”（chosen-prefix collisions）来进行此次攻击（是王小云所使用的攻击方法的改进版本）。  
他们所使用的计算机是一台 Sony PS3，且仅用了不到两天。  
他们的结论：MD5 算法不应再被用于任何软件完整性检查或代码签名的用途！  
另：现在，如果仅仅是想要生成 MD5 相同而内容不同的文件的话，在任何主流配置的电脑上用几秒钟就可以完成了。  
  
这几位密码学家编写的快速 MD5 碰撞生成器：[fastcoll_v1.0.0.5.exe.zip](http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip)    
源码：[fastcoll_v1.0.0.5_source.zip](http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5_source.zip)  
  
## 推荐一个 MD5 密码碰撞网站  
[MD5反向查询网站](http://www.cmd5.com/)  
  
本站针对md5、sha1等全球通用公开的加密算法进行反向查询，通过穷举字符组合的方式，创建了明文密文对应查询数据库，创建的记录约90万亿条，占用硬盘超过500TB，查询成功率95%以上，很多复杂密文只有本站才可查询。已稳定运行十余年，国内外享有盛誉。   
  
**实时查询解密范围:**  
山东大学王小云教授发现了md5的碰撞原理震惊了世界，本站就是专门针对全球通用的md5等算法进行反向解密，实时查询拥有全世界最大的数据库，实测解密成功率在95%以上，有的用户已经超过了98%。目前世界上同类网站越来越多，但是我们一直保持着遥遥领先的优势。即使千万条以上的数据，我们一个小时就能解密到90%以上的水平，其余绝大部分时间都是为了提高哪怕一个百分点的成功率。本站帮您最大限度的恢复数据价值。  
  
本站还支持dz、vb、mssql等实时查询和实时批量解密，此类带salt(加盐)的加密类型，由于算法的特殊性，一般方法无法建库，本站采用独特技术，在保证最高成功率的前提下，实现了实时批量解密，这在全球都是绝无仅有的，2010年正式上线以来，至今没有其它任何一家真正实现了此功能。  
  
密文破解早已经变成了资金密集型和技术密集型的行业，本站在全球的领先优势持续扩大，在美国，在俄罗斯，在中国，行业内无人不识cmd5。有些密文只有本站可以破解，除此以外别无他法，如果本站不能破出，你就没有任何办法。     
  
本站的数据量比世界上任何其它网站都超过36倍以上，举个很简单的例子，任何网站很难收录到8位小写字母，而本站全部收录8位小写字母+数字。也就是说，本站数据95%以上都是全球独有的。  
  
除此以外，本站筹建了独立服务器，收录了一批极为冷僻的数据，这些数据命中的几率非常低，因此相对成本要高出很多。但仍然按普通的计费。  
  
| MD5 收录内容 | 说明 | 数量 |  
| ------------ | ------------ | ------------ |  
| 1-6位大小写字母+数字+特殊字符 | 收录100% | 大于  1400亿 |  
| 7位小写字母+数字 | 收录100% | 大于    783亿 |  
| 8位小写字母+数字 | 收录100% | 大于28211亿 |  
| 9位小写字母 | 已收录30%，正在添加 | 大于14000亿 |  
| 8-11位数字 | 收录100% | 大于  1000亿 |  
| 1-15位其它数据 | 部分收录 | 大于28000亿 |  
| 1-20位 | 900G独家超大字典 | 大于    910亿 |  
  
2016-12-28  
